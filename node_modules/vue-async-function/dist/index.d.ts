import { Ref } from "@vue/composition-api";
declare type AsyncFunction<T, P> = (params: P, signal: AbortSignal) => Promise<T>;
interface AsyncFunctionReturn<T> {
    isLoading: Ref<boolean>;
    error: Ref<any>;
    data: Ref<T | undefined>;
    abort: () => void;
    retry: () => void;
}
/**
 * Async helper function that returns three reactive values:
 * * `isLoading`, a boolean that is true during pending state;
 * * `data`, contains the resolved value in the fulfilled state; and
 * * `error`, contains the exception in the rejected state.
 *
 * It returns the following functions as well:
 * * `abort`, that aborts the current promise
 * * `retry`, that retries the original promise
 *
 * @param promiseFn (optionally ref to) function that returns a Promise.
 * @param params (optionally ref to) parameters passed as first argument to the promise function.
 * @returns Object literal containing `isLoading`, `error` and `data` value wrappers and `abort` and `retry`
 * functions.
 */
export declare function useAsync<T, P>(promiseFn: AsyncFunction<T, P> | Ref<AsyncFunction<T, P>>, params?: P | Ref<P>): AsyncFunctionReturn<T>;
/**
 * Fetch helper function that accepts the same arguments as `fetch` and returns the same values as `useAsync`.
 * If the `Accept` header is set to `application/json` in the `requestInit` object, the response will be parsed as JSON,
 * else text.
 *
 * @param requestInfo (optionally ref to) URL or request object.
 * @param requestInit (optionally ref to) init parameters for the request.
 * @returns Object literal containing same return values as `useAsync`.
 */
export declare function useFetch<T>(requestInfo: RequestInfo | Ref<RequestInfo>, requestInit?: RequestInit | Ref<RequestInit>): AsyncFunctionReturn<T>;
export {};
