{"version":3,"sources":["../src/index.ts"],"names":["ref","isRef","watch","onBeforeUnmount","useAsync","promiseFn","params","wrapPromiseFn","wrapParams","isLoading","error","data","controller","abort","value","undefined","retry","origPromiseFn","signal","watched","newPromiseFn","newParams","AbortController","result","useFetch","requestInfo","requestInit","wrapReqInfo","wrapReqInit","doFetch","fetch","res","ok","headers","Accept","json","text"],"mappings":"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","sourcesContent":["import { ref, Ref, isRef, watch, onBeforeUnmount } from \"@vue/composition-api\";\n\ntype AsyncFunction<T, P> = (params: P, signal: AbortSignal) => Promise<T>;\n\ninterface AsyncFunctionReturn<T> {\n  isLoading: Ref<boolean>;\n  error: Ref<any>;\n  data: Ref<T | undefined>;\n  abort: () => void;\n  retry: () => void;\n}\n\n/**\n * Async helper function that returns three reactive values:\n * * `isLoading`, a boolean that is true during pending state;\n * * `data`, contains the resolved value in the fulfilled state; and\n * * `error`, contains the exception in the rejected state.\n *\n * It returns the following functions as well:\n * * `abort`, that aborts the current promise\n * * `retry`, that retries the original promise\n *\n * @param promiseFn (optionally ref to) function that returns a Promise.\n * @param params (optionally ref to) parameters passed as first argument to the promise function.\n * @returns Object literal containing `isLoading`, `error` and `data` value wrappers and `abort` and `retry`\n * functions.\n */\nexport function useAsync<T, P>(\n  promiseFn: AsyncFunction<T, P> | Ref<AsyncFunction<T, P>>,\n  params?: P | Ref<P>\n): AsyncFunctionReturn<T> {\n  // always wrap arguments\n  const wrapPromiseFn = isRef<AsyncFunction<T, P>>(promiseFn)\n    ? promiseFn\n    : ref<AsyncFunction<T, P>>(promiseFn);\n  const wrapParams: Ref<P> = isRef<P>(params) ? params : ref(params);\n\n  // create empty return values\n  const isLoading = ref<boolean>(false);\n  const error = ref<any>();\n  const data = ref<T>();\n\n  // abort controller\n  let controller: AbortController | undefined;\n\n  function abort() {\n    isLoading.value = false;\n    if (controller !== undefined) {\n      controller.abort();\n      controller = undefined;\n    }\n  }\n\n  function retry() {\n    // unwrap the original promise as it is optionally wrapped\n    const origPromiseFn = wrapPromiseFn.value;\n    // create a new promise and trigger watch\n    wrapPromiseFn.value = async (params, signal) =>\n      origPromiseFn(params, signal);\n  }\n\n  // watch for change in arguments, which triggers immediately initially\n  const watched: [typeof wrapPromiseFn, typeof wrapParams] = [\n    wrapPromiseFn,\n    wrapParams,\n  ];\n  watch(watched, async ([newPromiseFn, newParams]) => {\n    try {\n      abort();\n      isLoading.value = true;\n      controller = new AbortController();\n      const result = await newPromiseFn(newParams, controller.signal);\n      error.value = undefined;\n      data.value = result;\n    } catch (e) {\n      error.value = e;\n      data.value = undefined;\n    } finally {\n      isLoading.value = false;\n    }\n  });\n\n  onBeforeUnmount(abort);\n\n  return {\n    isLoading,\n    error,\n    data,\n    abort,\n    retry,\n  };\n}\n\n/**\n * Fetch helper function that accepts the same arguments as `fetch` and returns the same values as `useAsync`.\n * If the `Accept` header is set to `application/json` in the `requestInit` object, the response will be parsed as JSON,\n * else text.\n *\n * @param requestInfo (optionally ref to) URL or request object.\n * @param requestInit (optionally ref to) init parameters for the request.\n * @returns Object literal containing same return values as `useAsync`.\n */\nexport function useFetch<T>(\n  requestInfo: RequestInfo | Ref<RequestInfo>,\n  requestInit: RequestInit | Ref<RequestInit> = {}\n): AsyncFunctionReturn<T> {\n  // always wrap arguments\n  const wrapReqInfo = isRef<RequestInfo>(requestInfo)\n    ? requestInfo\n    : ref<RequestInfo>(requestInfo);\n  const wrapReqInit = isRef<RequestInit>(requestInit)\n    ? requestInit\n    : ref<RequestInit>(requestInit);\n\n  async function doFetch(params: undefined, signal: AbortSignal) {\n    const requestInit = wrapReqInit.value;\n    const res = await fetch(wrapReqInfo.value, {\n      ...requestInit,\n      signal,\n    });\n    if (!res.ok) {\n      throw res;\n    }\n\n    // TODO figure out how to use typed headers\n    const headers: any = requestInit.headers;\n    if (headers && headers.Accept === \"application/json\") {\n      return res.json();\n    }\n    return res.text();\n  }\n\n  // wrap original fetch function in value\n  const wrapPromiseFn = ref<AsyncFunction<T, undefined>>(doFetch);\n\n  // watch for change in arguments, which triggers immediately initially\n  watch([wrapReqInfo, wrapReqInit], async () => {\n    // create a new promise and trigger watch\n    wrapPromiseFn.value = async (params, signal) => doFetch(params, signal);\n  });\n\n  return useAsync(wrapPromiseFn);\n}\n"],"file":"index.js"}